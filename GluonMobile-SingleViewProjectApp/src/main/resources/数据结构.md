### 要求：能写出各种算法的步骤

### 线性表

线性表的定义和基本操作 线性表的顺序存储和链式存储 线性表的应用
 顺序

 ```C
 struct List {
   int data[maxSize];
   int length;
 }
 ```

 链式

 ```C
 struct LNode {
   elemType data;
   LNode *next;
 }
 typedef List *LNode;
 ```

### 数组压缩

数组压缩存储,行优先,数组下标从0开始$A[0,n-1]$

元素$a_{ij}$在数组中的下标$k$

1 对称矩阵  

$$
\begin{aligned}
k&=1+2+3+\cdots+(i-1)+j-1,(-1是因为数组下标从0开始)\\
 &= \frac {i(i-1)} 2 +j-1, (i>=j);下三角包括对角线\\

k&=\frac {j(j-1)} 2 +i-1, (i \lt j))上三角不包括对角线
\end{aligned}
$$

2 下三角矩阵

$$
k=\frac {i(i-1)} 2 +j-1 ,(i \ge j), \\
k=\frac {n(n+1)} 2 ,(i \lt j)).
$$

3 上三矩阵

$$
k=\frac {(i-1)(2n-i+2)} 2 + (j-i) ,(i \le j), \\
k=\frac {n(n+1)} 2 (i \lt ,)).
$$

4 三对角矩阵.

$$
k=2i+j-3， i=[\frac {(k+1)} 3 + 1] , 向下取整
$$

### 栈的顺序存储

 ```C
   struct Stack {
     int data[maxSize];
     int top; // 栈顶指针
   }

    top==-1;// 空
    top==maxSize-1 // 满
    // 插入
    top++; data[top]=e;
    // 弹出
    e=data[top]; top--;
```

### 队列的顺序存储， 先进先出，尾进头出，循环队列就想"围巾"

```C
  struct Queue {
    int data[maxSize];
    int front; // 队首指针
    int rear;  // 队尾指针
  }

  front=rear=0;// 初始值


  rear==front; //空
  (rear+1)%maxSize==front;//满
  rear=(rear+1)%maxSize; data[rear]=e; // 入队
  front=(front+1)%maxSize;  e=data[front];// 出队

  ```

// 链式结构，使用带头指针和尾指针的链表

### 树与二叉树

树：高度:根结点是第一层高,度为$1$.  
$N=D+1$,即结点数=度数+1

二叉树：
  结点 $N_0=N_2+1$;

满二叉树：结点数$2^k-1, k=1,2,3...$

### 完全二叉树特点

1. $1到n$编号;  
2. 叶子结点只能出现在最下两层;  
3. 至多只有一个度为$1$的结点且是左孩子;
4. 第$i$个结点,其父结点$i/2$,左孩子$2i$,右孩子$2i+1$,所在层$\log_2{i}+1$,
5. $i \le n/2$ 是分支结点,否则是叶子结点，
6. 若$i$是叶子结点或只有左孩子,则大于$i$的结点都是叶子结点,

### 二叉树的顺序存储：按完全二叉树存储，数组

顺序存储

```C

struct Node {
    elemType data;
    Node *lchild rchild;
}

typedef Node *BiTree;
```

### 二叉树的遍历方式

先序(根左右）、中序(左根右)、后序(左右根)

1 先序递归遍历

```C
void preOrder {
  if (t->notNull) {
    visit(t);
    preOrder(t->lchild);
    preOrder(t->rchild);
}
```

2 深度遍历使用栈结构,中序遍历：  
左子树入栈直到最下面的，弹出访问，
其右子树入栈

3 层次遍历使用队列结构

出队列，访问，左子树入栈，右子树入栈

```C
while(queue->isNotEmpty) {
  p=queue->pop();
  visit(p);
  if(notNull) queue->push(p->lchild);
  if(notNull) queue->push(p->rchild);
}
```

### 线索二叉树定义

若左右子树为空，则可以用来对应放置前驱和后继

### 树链式存储

左孩子右兄弟

### 栈和队列应用

二叉排序树：左小右大，

    插入的结点一定是叶子结点.

    删除策略：
    1）如果是叶子结点，直接删除；
    2）若结点只有一颗子树，则让其子树替代它；
    3）若有两棵子树,用其直接后继替代它,  
    转变成(1)或(2),  
    直接后继是-右子树的最下个左孩子

### 平衡二叉树

* 平衡二叉树也是二叉排序树，其插入过程二与叉排序树相同，
* 平衡因子=左子树的高度-减去右子树的高度
* RR-左孩子的左子树，向右旋转
* LL-右孩子的右子树，向左旋转
* LR-左孩子的右子树，先左后右
* RL-右孩子的左子树，先右后左

### 深度和广度遍历

树和图的深度优先，使用“栈”结构访问，先进后出
树和图的广度优先，使用“队列”结构访问，先进先出

### 最小代价生成树

最小代价生成树MST：带权的图，无回路，n个顶点n-1条边 权值和最小,最后必然是一棵树.

树不唯一；权值和唯一

### Prim：普里姆最小代价生成树（核心-找最小边）

步骤:  
1)选一个顶点，作为一棵树T;  
2)选择一条和树连接的权最小的边，将这个边和对应的点加入到树T，形成新的树T （无回路）;  
3)重复上面2，直到有n个顶点n-1条边

### Kk算法最小代价生成树：(核心-排序）克鲁斯卡

1）图中每一个顶点作为一颗树,;  
2）将边按从小到大顺序排列;  
3）依次将边取出,连接,且保证不出现回路.  
4）重复步骤3，直到剩下一颗树 包含n个顶点n-1条边;

--最短路径：有向带权图,任意两点间的最短路径
Dk算法：迪杰斯特拉 (有向-找最小，一根线）
1）选择一个点V1当起点，将起点视为一个图G, 其余点集合为U
2）比较V1到U中点的路径长度，从U中取出(getAndRemove)该点v，并入图G
点v满足，V1（沿着G的任意路径）到U中点路径长度最短的点
3）重复步骤2，直到G包含n个点

--拓扑排序：AOV(活动在点上） 有向无回路的图，事情发生的先后顺序
1）从图中选择一个入度=0的弧，并输出它
2）从图中删除该点，并且删除该点的出弧，弧头点入度-1
3）重复1和2直到顶点全部输出
4）如果还有点没输入，没有入度=0的点，说明有回路，失败

--关键路径：带权有向图 AOE 一个源点和一个汇点
具有最大路径长度的路径叫关键路径
关键路径上的活动都是关键活动
只有某点的事件发生后，从该点出发的活动才能开始
只有某点入度上的活动都完成后，该点的事件才能发生

--B树
1）多路平衡树 （m叉树 至多m个子树 至少m/2（上）树（根结点至少2个））
2）关键字有序
3）结点上多个关键字 且关键字个数=子树个数-1，关键字是相邻两子树关键字的“中间值”   子树|关键字|子树|
4）查找类似二叉排序树
5）所以叶子结点都在同一层且不带任何信息

***插入  关键字个数 >=m/2(上）-1；关键字个数有上限， 比如m=5，子树[3,5],关键字[2,4]，插入删除后要调整
   删除  关键字比子树要小1，不符合要调整
   调整  a)子树的关键字到父，子分裂；b)父的关键字到右边子，子合并

--B+
1）多路平衡 （m叉树 至多m个子树 至少m/2（上）树（根结点至少2个）） 5/2=3
2）关键字有序
3）结点上多个关键字 且关键字个数=子树个数，关键字是对应子树关键字的“最大值”
4）查找类似分块查找
5）叶子结点包含所有关键字，并放在一个链表里，在最下层

--散列查找
装填因子=表中记录数/散列表长度
散列函数：
1 直接地址发 Hash(key)=a*key+b
2 数字分析法
2 平方取中法
4 除留余数法 Hash(key)=key%P
5 随机数法 Hash(key)=random(key)
碰撞处理
1 链接法 把散列到同一个地址中的所有元素放到一个链表中 平均查找长度 1+(α/2)
2 溢出表法 凡是发生冲突的元素都放入溢出表
3 开放寻址法
    1）线性探查Hi=(H0+i)%m  平均查找长度：(1 + 1/(1- α))/2
    2) 二次（平方）探查Hi=(H0+i^2)%m
    3) 双重散列Hi=(H0+i*Hash(key))%m


-----------排序------------
* 插入排序：前部分有序，将后部分依次插入已经有序的部分，对有序的部分从后往前找，保证其 稳定性；
* 希尔排序：缩小增量的分组插入排序
1）取一个步长 d1 ,记录分d1 组，所有距离d1的倍数的项为同一组，在各组中进行直接插入排序
2）去 d2<d1
3) 重复 1，2，直到 d=1，所有记录同一组，再进行最后一次直接插入排序

void shellShort(Type arr[],int n) { // n 是元素个数
    // d 步长
    int length=n+1 // 数组长度，从1开始
    for (int d=n/2;d>=1;d=d/2)
        for (int i=1;i<=d;i++) { // arr[0] 当扫哨兵
            for (int j=i+d; j<length;j=j+d) {
                insertSort(arr, d, i) // 对数组arr的第i个元素使用增量d插入排序
            }
        }
    }
}

--气泡排序：比较交换
--快速排序：递归的冒泡排序, 冒泡分两部分，其中各部分递归再冒泡
1) 选定一个元素a，左边的元素<=a, 右边的元素>a
2) 递给调用前后两部分，进行快速排序
void quickSort(Type arr[], int p, int r) { /[p,r]
    int q;
    if (p<r) {
        q = partition(arr, p, r);    // 使用第一个元素*q比较，partition 将p-r 分两部分
                                     // arr[p,q-1]<= arr[q], arr[q+1,r]>arr[q]
        quickSort(arr, p, q-1);
        quickSort(arr, q+1,r);
    }
}

partition() 使用冒泡法，先往上冒泡，下面的都小于它，再往下冒泡，上面都大于它；

* 简单选择排序：选后面最小的素依次放到前面,[i,n] 中选择最小的元素与 *i 交换
* 堆排序： 对标简单选择排序，它使用堆的方式选择前面最大的，放在后面
  堆是一个完全二叉树，<="n/2" 是分支结点 [1,n/2] 进行调整
  大顶堆：最大值在根部，结点值>=左右孩子值
使用顺序表
 建大根堆 ， 结点下标从1开始，n个结点
 1）从树种最后一个非叶子节点开始（最后一个元素的父节点n/2）向前对各个元素进行调整, 直到 1；
 2）看每个节点是否大于等于">="左右孩子节点，如果不是，将结点与其中较大的孩子交换
 3）如果交换，对交换的子树(如果有孩子）继续向下交换

 4）堆顶元素是最大值，将1 和 n 交换，n=n-1，大的元素放在后面
 5）从 1 向下调整，重新恢复大顶堆

 6）重复 4，5 直到n=1
void heapSort(Type arr[], int n) {
    buildMaxHeap(A,n); // 建堆，最大值在堆顶
    for(i=n;i>1;i--) {
        swap(arr[i],a[1]); // 堆顶1最大值 交换i 到后面
        adjustDown(arr,1,i-1); // 整理成新的堆
}

基数排序：   从低位向高位排序，个、十、百...
二路归并排序: 递归的排序，先排序，再合并， 1-1， 2-2， 4-4
是将规模较大的排序，分解成若干较小规模的序列，将其分别排好序后在合并成一个有序队列的算法
1 分解n个元素分解成n/2个子序列
2 将两个子序列进行排序，使其有序(使用的也是归并排序)子序列只有一个元素就不用排序了
3 合并
void mergeSort(Type arr[], int left, int right) {
    if (left<right) {
        int mid=(left+right)/2
        mergeSort(arr, left, mid);
        mergeSort(arr, mid+1，right);
        merge(a, left, mid, right);
    }
}

merge(): 是将两个有序的序列合并, 需要一个辅助数组

--10-12

算法的稳定性：关键字相同的元素，排序后其前后关系不变，则算法是稳定的
